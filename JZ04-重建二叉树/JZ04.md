## JZ4 重建二叉树
### 描述：
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

### 思路：
关键点1： 二叉树的前/中/后序遍历概念 + 递归
二叉树的前序遍历：根左右
二叉树的中序遍历：左根右
二叉树的后序遍历：左右根

关键点2： 索引取值图示，以前序遍历{1，2，3，4，5，6，7}，中序遍历{3，2，4，1，6，5，7}为例
首先根据前序遍历找到新二叉树的根结点，是前序遍历的第1个结点{1}
```C++
TreeNode* root = new TreeNode(pre[pre_left]);
```
接着对中序遍历结果进行遍历，当`if(vin[i] == root->val)`说明找到了左右子树的分界点，开始递归，第1次递归，i = 3,

|  pre  |  |  |  |  |  |  |  |
|  ---- | ----| ----| ----| ----| ----| ----| ----|
| index | (0) | (1) | (2) | (3) | (4) | (5) | (6) |
| value |  1  |  2  |  3  |  4  |  5  |  6  |  7  |
| code  |  pre_left  |  2  |  3  |  pre_left+i-vin_left  |  pre_left+i-vin_left+1  |  6  |  pre_right  |

|  vin  |  |  |  |  |  |  |  |
|  ---- | ----| ----| ----| ----| ----| ----| ----|
| index | (0) | (1) | (2) | (3) | (4) | (5) | (6) |
| value |  3  |  2  |  4  |  1  |  6  |  5  |  7  |
| code  |  vin_left  |  2  |  i-1  |  i  |  i+1  |  5  |  vin_right  |

i-vin_left 为左子树有几个结点
